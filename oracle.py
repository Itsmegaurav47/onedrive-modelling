# -*- coding: utf-8 -*-
"""oracle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jk9hEZ409u8mTlBj-S_dZqkw9DhWV6YA
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Set, Optional, Tuple, List


# ========== Core Data Types (Section 4 & 5 of Formal Model) ==========

@dataclass
class User:
    """
    Represents a user in the OneDrive Personal system.
    Corresponds to ð’° (Users) in Section 4.1 of the formal model.

    Attributes
    ----------
    uid : str
        Unique identifier for the user.
    user_type : str
        One of: "owner", "authenticated", "anonymous"
        Maps to u_owner, u_auth, u_anon in the formal model.
    name : str
        Display name of the user.
    """
    uid: str
    user_type: str  # "owner" | "authenticated" | "anonymous"
    name: str = ""


@dataclass
class Resource:
    """
    Represents a resource (file or folder) in OneDrive.
    Corresponds to â„› (Resources) in Section 4.2 of the formal model.

    Attributes
    ----------
    rid : str
        Unique resource identifier.
    name : str
        Display name of the resource.
    resource_type : str
        Either "file" or "folder"
        Maps to â„›_files and â„›_folders in the formal model.
    parent_id : Optional[str]
        ID of parent folder; None for root (âŠ¥).
        Implements the parent relation from Section 5.2.
    is_vault : bool
        True if resource is in Personal Vault (â„›_vault).
        See Section 2.3 and Invariants 3-4, 6.
    """
    rid: str
    name: str
    resource_type: str  # "file" | "folder"
    parent_id: Optional[str] = None  # None = root (âŠ¥)
    is_vault: bool = False


@dataclass
class Link:
    """
    Represents a sharing link (capability token).
    Corresponds to â„’ (Links/Tokens) in Section 4.4 of the formal model.

    Attributes
    ----------
    lid : str
        Unique link identifier.
    target_rid : str
        Resource this link points to (attr(l). target).
    scope : str
        Either "ANYONE" or "SPECIFIC" (S_l in Section 5.3).
    perms : Set[str]
        Permission set: {"view"} or {"view", "edit"} (P_l in Section 5.3).
        Note: Stored as set, but effective permissions computed via perms_effective.
    constraints : Dict[str, any]
        Optional constraints (C_l in Section 5.3):
        - "expiry": datetime | None
        - "password": str | None
    key : str
        The unique URL token (K_l in Section 5. 3).
        Invariant 8: Keys must be unique across all links.
    """
    lid: str
    target_rid: str
    scope: str  # "ANYONE" | "SPECIFIC"
    perms: Set[str]  # {"view"} or {"view", "edit"}
    constraints: Dict[str, any] = field(default_factory=dict)
    key: str = ""


@dataclass
class Context:
    """
    Request context Î“ (gamma) from Section 7.1 of the formal model.

    Attributes
    ----------
    t_now : datetime
        Current timestamp for expiration checks.
    auth_level : str
        Authentication level: "none", "standard", or "mfa"
        Required for Vault access (Invariant 6).
    provided_password : Optional[str]
        Password supplied by user for password-protected links.
    """
    t_now: datetime
    auth_level: str = "none"  # "none" | "standard" | "mfa"
    provided_password: Optional[str] = None


@dataclass
class OneDriveState:
    """
    Global system state representing the complete OneDrive Personal account.
    Corresponds to State S in Section 5 of the formal model.

    Attributes
    ----------
    owner_id : str
        User ID of the account owner (u_owner).
        Invariant 1: Every resource has exactly this owner.
    users : Dict[str, User]
        Set of all users (ð’°).
    resources : Dict[str, Resource]
        Set of all resources (â„›).
        Forms a tree structure via parent_id (Invariant 2).
    links : Dict[str, Link]
        Set of all active sharing links (â„’).
    recipients : Dict[str, Set[str]]
        Maps link_id â†’ set of user_ids for SPECIFIC links.
        Implements recipients relation from Section 5.4.
        Invariant 9: For SPECIFIC links, recipients âŠ† U_auth.
    holding : Set[Tuple[str, str]]
        Set of (user_id, link_id) pairs indicating link possession.
        Implements holding relation from Section 5.4.
    """
    owner_id: str
    users: Dict[str, User] = field(default_factory=dict)
    resources: Dict[str, Resource] = field(default_factory=dict)
    links: Dict[str, Link] = field(default_factory=dict)
    recipients: Dict[str, Set[str]] = field(default_factory=dict)
    holding: Set[Tuple[str, str]] = field(default_factory=set)


# ========== Helper Functions (Section 5.2, 7) ==========

def is_ancestor(ancestor_rid: str, child_rid: str, state: OneDriveState) -> bool:
    """
    Implements the is_ancestor(p, c) relation from Section 5.2.

    Returns True if ancestor_rid is a parent (recursively) of child_rid.
    Used for permission inheritance.

    Invariant 2: The hierarchy must be acyclic (no r where is_ancestor(r, r)).
    """
    if child_rid not in state.resources:
        return False

    current = state.resources[child_rid]
    while current.parent_id is not None:
        if current.parent_id == ancestor_rid:
            return True
        if current.parent_id not in state.resources:
            break
        current = state.resources[current.parent_id]
    return False


def descendants(rid: str, state: OneDriveState) -> Set[str]:
    """
    Helper for DeleteResource operation (Section 9.10).

    Returns the set of all resources d such that is_ancestor(rid, d) is True.
    Used for cascade deletion.
    """
    desc = set()
    for r in state.resources.values():
        if is_ancestor(rid, r.rid, state):
            desc.add(r.rid)
    return desc


def perms_effective(link: Link) -> Set[str]:
    """
    Implements Effective Permission Expansion from Section 4.3.1.

    Definition:
        l. perms^effective = {view, edit}  if edit âˆˆ l.perms
                          = {view}         if l.perms = {view}

    This captures the subsumption: edit â‰» view (edit includes view).
    """
    if "edit" in link.perms:
        return {"view", "edit"}
    else:
        return {"view"}


def req(action: str) -> str:
    """
    Implements the req: ð’œ â†’ ð’« function from Section 4.3.1.

    Maps actions to required permissions:
    - view, download â†’ "view"
    - edit, upload, delete, share â†’ "edit"

    Returns
    -------
    str
        Required permission: "view" or "edit"
    """
    view_actions = {"view", "download"}
    edit_actions = {"edit", "upload", "delete", "share"}

    if action in view_actions:
        return "view"
    elif action in edit_actions:
        return "edit"
    else:
        # Default: treat unknown actions as requiring edit
        return "edit"


# ========== Policy Logic Predicates (Section 7) ==========

def valid_link(link: Link, user: User, action: str,
               ctx: Context, state: OneDriveState) -> bool:
    """
    Implements ValidLink(l, u, a, Î“) predicate from Section 7.2.

    A link is valid if ALL of the following hold:
    1.  Possession: (u, l) âˆˆ holding
    2. Identity: (scope = ANYONE) âˆ¨ (u âˆˆ recipients(l))
    3.  Expiration: expiry constraint not violated
    4. Password: password constraint satisfied
    5. Permissions: req(a) âˆˆ l.perms^effective

    Parameters
    ----------
    link : Link
        The sharing link being evaluated.
    user : User
        The user attempting access.
    action : str
        The action being performed.
    ctx : Context
        Request context (time, auth level, password).
    state : OneDriveState
        Current system state.

    Returns
    -------
    bool
        True if all five conditions are satisfied.
    """
    # 1. Possession check
    if (user.uid, link.lid) not in state.holding:
        return False

    # 2. Identity check (scope)
    if link.scope == "SPECIFIC":
        if link.lid not in state.recipients:
            return False
        if user.uid not in state.recipients[link.lid]:
            return False
    # For ANYONE scope, identity check always passes

    # 3. Expiration check
    if "expiry" in link.constraints and link.constraints["expiry"] is not None:
        if not (ctx.t_now < link.constraints["expiry"]):
            return False

    # 4. Password check
    if "password" in link.constraints and link.constraints["password"] is not None:
        if ctx.provided_password != link.constraints["password"]:
            return False

    # 5. Permission check using effective permissions
    needed_perm = req(action)
    effective_perms = perms_effective(link)
    if needed_perm not in effective_perms:
        return False

    return True


def vault_access(user: User, resource: Resource,
                 ctx: Context, state: OneDriveState) -> bool:
    """
    Implements VaultAccess(u, r, Î“) predicate from Section 7.3.

    The Personal Vault barrier:
    - Non-vault resources: always True
    - Vault resources: requires (u = owner) âˆ§ (auth_level = mfa)

    Enforces Invariant 6: Vault MFA Requirement.

    Returns
    -------
    bool
        True if access to this resource (vault or not) is allowed.
    """
    if not resource.is_vault:
        return True

    # Vault resource: must be owner with MFA
    return (user.uid == state.owner_id and
            ctx.auth_level == "mfa")


def can_manage(user: User, resource: Resource,
               ctx: Context, state: OneDriveState) -> bool:
    """
    Implements CanManage(u, r, Î“) predicate from Section 7.4.

    Determines if a user can modify access control (create/delete links,
    add/remove recipients) for a resource.

    CanManage(u, r, Î“) âŸº (u = u_owner) âˆ¨ (edit âˆˆ TotalPerms(u, r, Î“))

    Used by Invariant 5 (Link Management Consistency).

    Returns
    -------
    bool
        True if user can manage access for this resource.
    """
    if user.uid == state.owner_id:
        return True

    total = total_perms(user, resource, ctx, state)
    return "edit" in total


def direct_perms(user: User, resource: Resource,
                 ctx: Context, state: OneDriveState) -> Set[str]:
    """
    Implements DirectPerms(u, r, Î“) from Section 7.5.

    Returns the union of permissions from all valid links that directly
    target this resource.

    DirectPerms(u, r, Î“) = â‹ƒ {l.perms | l.target = r âˆ§ ValidLink(l, u, view, Î“)}
    """
    perms = set()
    for link in state.links. values():
        if link.target_rid == resource.rid:
            # Check validity for 'view' action (minimal requirement)
            if valid_link(link, user, "view", ctx, state):
                perms |= link.perms
    return perms


def inherited_perms(user: User, resource: Resource,
                    ctx: Context, state: OneDriveState) -> Set[str]:
    """
    Implements InheritedPerms(u, r, Î“) from Section 7.5.

    Returns the union of permissions from all valid links on ancestor folders.

    InheritedPerms(u, r, Î“) = â‹ƒ {l.perms | is_ancestor(l.target, r) âˆ§ ValidLink(l, u, view, Î“)}

    Implements hierarchical inheritance (System Characteristic 2).
    """
    perms = set()
    for link in state.links.values():
        if is_ancestor(link.target_rid, resource.rid, state):
            if valid_link(link, user, "view", ctx, state):
                perms |= link.perms
    return perms


def total_perms(user: User, resource: Resource,
                ctx: Context, state: OneDriveState) -> Set[str]:
    """
    Implements TotalPerms(u, r, Î“) from Section 7.5.

    Returns the union of direct and inherited permissions.
    Implements "Combined Permission Evaluation" (System Characteristic 6).

    TotalPerms(u, r, Î“) = DirectPerms(u, r, Î“) âˆª InheritedPerms(u, r, Î“)

    Note: Union semantics prevent permission downgrade.  If a folder grants
    edit, no child can be restricted to view-only.
    """
    return (direct_perms(user, resource, ctx, state) |
            inherited_perms(user, resource, ctx, state))


# ========== Authorization Oracle (Section 8) ==========

def decide_access(user: User, resource: Resource, action: str,
                  ctx: Context, state: OneDriveState) -> str:
    """
    Main Authorization Oracle implementing decide_access from Section 8.

    Decision logic:
    1.  DENY if Â¬VaultAccess(u, r, Î“)         [Vault barrier]
    2. GRANT if u = u_owner                   [Owner override]
    3.  GRANT if req(a) âˆˆ TotalPerms(u, r, Î“)  [Standard check]
    4. DENY otherwise

    Parameters
    ----------
    user : User
        The user requesting access.
    resource : Resource
        The target resource.
    action : str
        The action to perform (view, download, edit, upload, delete, share).
    ctx : Context
        Request context (time, auth level, password).
    state : OneDriveState
        Current system state.

    Returns
    -------
    str
        "GRANT" or "DENY"
    """
    # 1. Vault barrier (Section 7.3)
    if not vault_access(user, resource, ctx, state):
        return "DENY"

    # 2. Owner override (System Characteristic 1)
    if user.uid == state.owner_id:
        return "GRANT"

    # 3. Standard permission check
    needed_perm = req(action)
    user_perms = total_perms(user, resource, ctx, state)

    if needed_perm in user_perms:
        return "GRANT"

    # 4. Default deny
    return "DENY"


# ========== Administrative Operations (Section 9) ==========
# These implement state transitions from the formal model

def create_link(user: User, target: Resource, scope: str,
                perms: Set[str], constraints: Dict[str, any],
                state: OneDriveState, ctx: Context) -> Optional[Link]:
    """
    Implements CreateLink operation from Section 9.1.

    Precondition: (u = u_owner âˆ¨ edit âˆˆ TotalPerms(u, target, Î“)) âˆ§ target âˆ‰ â„›_vault

    Effect: â„’' = â„’ âˆª {l_new}

    Enforces Invariant 3 (Vault Non-Shareability).
    Enforces Invariant 10 (Constraint-Scope Consistency).
    """
    # Check preconditions
    if target.is_vault:
        return None  # Cannot share Vault resources

    # Check authority
    if user.uid != state.owner_id:
        if "edit" not in total_perms(user, target, ctx, state):
            return None

    # Validate Invariant 10: constraints only on ANYONE links
    if constraints and scope != "ANYONE":
        return None

    # Create new link
    new_lid = f"link_{len(state.links) + 1}"
    new_key = f"https://1drv.ms/{new_lid}"  # Generate unique key

    new_link = Link(
        lid=new_lid,
        target_rid=target.rid,
        scope=scope,
        perms=perms,
        constraints=constraints,
        key=new_key
    )

    state.links[new_lid] = new_link

    # For SPECIFIC links, initialize recipients
    if scope == "SPECIFIC":
        state.recipients[new_lid] = set()

    return new_link

def update_constraints(user: User, link: Link, new_constraints: Dict[str, any],
                       state: OneDriveState, ctx: Context) -> bool:
    """
    Implements Modify Link Constraints (Section 9.5).
    """
    target = state.resources[link.target_rid]

    # Check authority
    if not can_manage(user, target, ctx, state):
        return False

    # Invariant 10 Check: Constraints only allowed on ANYONE links
    if new_constraints and link.scope != "ANYONE":
        return False

    link.constraints = new_constraints
    return True


def change_permissions(user: User, link: Link, new_perms: Set[str],
                       state: OneDriveState, ctx: Context) -> bool:
    """
    Implements Change Permissions (Section 9.6).
    """
    target = state.resources[link.target_rid]

    # Check authority
    if not can_manage(user, target, ctx, state):
        return False

    # Validate inputs (Must be view or view+edit)
    valid_sets = [{"view"}, {"view", "edit"}]
    if new_perms not in valid_sets:
        return False

    link.perms = new_perms
    return True


def copy_resource(user: User, source: Resource, destination_folder: Resource,
                  state: OneDriveState, ctx: Context) -> bool:
    """
    Implements Copy Resource (Section 9.7).
    Creates a new resource ID with new parent, breaking old link inheritance.
    """
    # Precondition: View on Source AND Edit on Destination
    if "view" not in total_perms(user, source, ctx, state):
        return False
    if "edit" not in total_perms(user, destination_folder, ctx, state):
        return False

    # Create Copy
    new_rid = f"{source.rid}_copy_{datetime.now().timestamp()}"
    new_res = Resource(
        rid=new_rid,
        name=f"Copy of {source.name}",
        resource_type=source.resource_type,
        parent_id=destination_folder.rid,
        is_vault=source.is_vault
    )

    state.resources[new_rid] = new_res
    return True


def add_user(user: User, link: Link, new_user: User,
             state: OneDriveState, ctx: Context) -> bool:
    """
    Implements AddUser operation from Section 9. 2.

    Precondition:
        CanManage(u, l. target, Î“) âˆ§
        (l.scope = SPECIFIC) âˆ§
        (new_user âˆˆ ð’°_auth)

    Effect:
        recipients'(l) = recipients(l) âˆª {new_user}
        holding' = holding âˆª {(new_user, l)}

    Enforces Invariant 9 (Scope-Recipients Consistency).
    """
    target = state.resources[link.target_rid]

    # Check preconditions
    if not can_manage(user, target, ctx, state):
        return False

    if link.scope != "SPECIFIC":
        return False

    if new_user. user_type != "authenticated":
        return False  # Invariant 9: only authenticated users

    # Update recipients and holding
    if link.lid not in state.recipients:
        state.recipients[link.lid] = set()

    state.recipients[link.lid].add(new_user.uid)
    state.holding.add((new_user.uid, link.lid))

    return True


def remove_user(user: User, link: Link, target_user: User,
                state: OneDriveState, ctx: Context) -> bool:
    """
    Implements RemoveUser operation from Section 9.3.

    Precondition: CanManage(u, l. target, Î“) âˆ§ (l.scope = SPECIFIC)

    Effect: recipients'(l) = recipients(l) \\ {target_user}

    Result: Other users on the same link retain access.
    """
    target = state.resources[link.target_rid]

    if not can_manage(user, target, ctx, state):
        return False

    if link.scope != "SPECIFIC":
        return False

    if link.lid in state.recipients:
        state.recipients[link.lid]. discard(target_user. uid)

    return True


def delete_link(user: User, link: Link,
                state: OneDriveState, ctx: Context) -> bool:
    """
    Implements DeleteLink operation from Section 9. 4.

    Precondition: CanManage(u, l.target, Î“)

    Effect: â„’' = â„’ \\ {l}

    Result: Access is lost for ALL users holding this capability token.
    """
    target = state.resources[link.target_rid]

    if not can_manage(user, target, ctx, state):
        return False

    # Remove link
    if link.lid in state. links:
        del state.links[link.lid]

    # Clean up recipients
    if link.lid in state.recipients:
        del state.recipients[link.lid]

    # Clean up holding relation
    state.holding = {(u, l) for (u, l) in state.holding if l != link. lid}

    return True


def move_resource(user: User, resource: Resource, new_parent: Resource,
                  state: OneDriveState, ctx: Context) -> bool:
    """
    Implements MoveResource operation from Section 9.9.

    Precondition:
        CanManage(u, resource, Î“) âˆ§
        (edit âˆˆ TotalPerms(u, new_parent, Î“))

    Effect: parent'(resource) = new_parent

    Result: Resource loses inherited permissions from old parent and gains
            inherited permissions from new parent.  Direct links remain valid.
    """
    # Check source authority
    if not can_manage(user, resource, ctx, state):
        return False

    # Check destination authority
    if "edit" not in total_perms(user, new_parent, ctx, state):
        return False

    # Move resource
    resource.parent_id = new_parent.rid

    return True


def delete_resource(user: User, resource: Resource,
                    state: OneDriveState, ctx: Context) -> bool:
    """
    Implements DeleteResource operation from Section 9.10.

    Precondition:
        (u = u_owner) âˆ¨ (edit âˆˆ TotalPerms(u, parent(resource), Î“))

    Effect:
        â„›' = â„› \\ ({resource} âˆª Descendants(resource))
        â„’' = {l âˆˆ â„’ | l. target âˆ‰ ({resource} âˆª Descendants(resource))}

    Implements cascade deletion and link garbage collection.
    Enforces Invariant 7 (Link-State Consistency).
    """
    # Owner can always delete
    if user.uid != state.owner_id:
        # Non-owner must have edit on parent
        if resource.parent_id is None:
            return False  # Cannot delete root

        parent = state.resources[resource.parent_id]
        if "edit" not in total_perms(user, parent, ctx, state):
            return False

    # Get all descendants
    to_delete = {resource. rid} | descendants(resource. rid, state)

    # Delete resources
    for rid in to_delete:
        if rid in state. resources:
            del state.resources[rid]

    # Garbage collect links (Invariant 7)
    links_to_delete = [lid for lid, link in state.links.items()
                       if link.target_rid in to_delete]

    for lid in links_to_delete:
        del state.links[lid]
        if lid in state.recipients:
            del state.recipients[lid]

    # Clean up holding relation
    state.holding = {(u, l) for (u, l) in state.holding
                     if l not in links_to_delete}

    return True


def create_resource(user: User, new_resource: Resource, parent: Resource,
                    state: OneDriveState, ctx: Context) -> bool:
    """
    Implements CreateResource operation from Section 9.11.

    Precondition: (u = u_owner) âˆ¨ (edit âˆˆ TotalPerms(u, parent, Î“))

    Effect:
        â„›' = â„› âˆª {new_resource}
        parent'(new_resource) = parent
        owns(u_owner, new_resource)

    Note: Ownership always remains with account owner.
    """
    # Check authority
    if user.uid != state.owner_id:
        if "edit" not in total_perms(user, parent, ctx, state):
            return False

    # Set parent and add to state
    new_resource.parent_id = parent.rid
    state.resources[new_resource.rid] = new_resource

    # Ownership is implicit (always owner_id)

    return True


def oracle(user: User, resource: Resource, action: str,
           ctx: Context, state: OneDriveState, **kwargs) -> str:
    """
    Unified Authorization Oracle for OneDrive Personal.

    This is the main entry point that handles:
    1. Resource access actions (view, download, edit, upload, delete)
    2. Administrative/management actions (share, update_access, manage_link)

    Implements the complete authorization logic from Sections 7-9 of the formal model.

    Parameters
    ----------
    user : User
        The user requesting the action.
    resource : Resource
        The target resource.
    action : str
        The action being performed.  Can be:

        **Resource Actions** (Section 4.3):
        - "view": Read file content
        - "download": Download file
        - "edit": Modify file content
        - "upload": Upload to folder
        - "delete": Delete resource
        - "share": Create new sharing link (re-sharing)

        **Administrative Actions** (Section 9):
        - "create_link": Create a new sharing link
        - "add_user": Add user to SPECIFIC link
        - "remove_user": Remove user from SPECIFIC link
        - "delete_link": Revoke a link
        - "update_constraints": Modify link expiry/password
        - "change_permissions": Change link permissions
        - "move": Move resource to new parent
        - "copy": Copy resource

    ctx : Context
        Request context (time, auth level, password).
    state : OneDriveState
        Current system state.
    **kwargs : dict
        Additional parameters for specific actions:
        - link: Link object (for link-related actions)
        - target_user: User object (for add_user/remove_user)
        - new_parent: Resource object (for move)
        - new_perms: Set[str] (for change_permissions)
        - new_constraints: Dict (for update_constraints)

    Returns
    -------
    str
        "GRANT" or "DENY"

    Examples
    --------
    >>> # Resource access
    >>> oracle(bob, my_file, "view", ctx, state)
    'GRANT'

    >>> # Create link (re-sharing)
    >>> oracle(alice, my_folder, "share", ctx, state)
    'GRANT'

    >>> # Link management
    >>> oracle(owner, my_file, "add_user", ctx, state, link=link1, target_user=bob)
    'GRANT'
    """

    # ========== Resource Access Actions (Section 8) ==========

    resource_actions = {
        "view", "download", "edit", "upload", "delete", "share"
    }

    if action in resource_actions:
        return _handle_resource_access(user, resource, action, ctx, state)

    # ========== Administrative Actions (Section 9) ==========

    # Link Creation (Section 9.1)
    if action == "create_link":
        return _handle_create_link(user, resource, ctx, state, kwargs)

    # Recipient Management (Sections 9.2, 9.3)
    if action == "add_user":
        return _handle_add_user(user, resource, ctx, state, kwargs)

    if action == "remove_user":
        return _handle_remove_user(user, resource, ctx, state, kwargs)

    # Link Management (Sections 9.4, 9.5, 9.6)
    if action == "delete_link":
        return _handle_delete_link(user, resource, ctx, state, kwargs)

    if action == "update_constraints":
        return _handle_update_constraints(user, resource, ctx, state, kwargs)

    if action == "change_permissions":
        return _handle_change_permissions(user, resource, ctx, state, kwargs)

    # Resource Operations (Sections 9.8, 9.9, 9.10, 9.11)
    if action == "copy":
        return _handle_copy_resource(user, resource, ctx, state, kwargs)

    if action == "move":
        return _handle_move_resource(user, resource, ctx, state, kwargs)

    # Note: "delete" is handled as a resource action above

    # Unknown action
    return "DENY"


# ========== Internal Handler Functions ==========

def _handle_resource_access(user: User, resource: Resource, action: str,
                            ctx: Context, state: OneDriveState) -> str:
    """
    Handle standard resource access using decide_access from Section 8.

    Special cases:
    1. "delete" requires edit on PARENT (not just resource) - Section 9.10
    2.  "share" (re-sharing) requires edit on resource - System Characteristic 5
    """

    # Special handling for DELETE (Section 9.10)
    if action == "delete":
        # Vault barrier
        if not vault_access(user, resource, ctx, state):
            return "DENY"

        # Owner can always delete
        if user. uid == state.owner_id:
            return "GRANT"

        # Non-owner must have edit on PARENT
        if resource.parent_id is None:
            return "DENY"  # Cannot delete root

        parent = state.resources. get(resource.parent_id)
        if not parent:
            return "DENY"

        parent_perms = total_perms(user, parent, ctx, state)
        return "GRANT" if "edit" in parent_perms else "DENY"

    # Special handling for SHARE (re-sharing)
    if action == "share":
        # Vault barrier
        if not vault_access(user, resource, ctx, state):
            return "DENY"

        # Owner can always share
        if user.uid == state.owner_id:
            return "GRANT"

        # Non-owner needs edit permission to re-share
        user_perms = total_perms(user, resource, ctx, state)
        return "GRANT" if "edit" in user_perms else "DENY"

    # Standard path: use decide_access
    return decide_access(user, resource, action, ctx, state)


def _handle_create_link(user: User, resource: Resource, ctx: Context,
                        state: OneDriveState, kwargs: dict) -> str:
    """
    Handle link creation (Section 9.1).

    Requires kwargs: scope, perms, constraints
    """
    # Check if user has authority to create link
    if not can_manage(user, resource, ctx, state):
        return "DENY"

    # Cannot share Vault resources (Invariant 3)
    if resource.is_vault:
        return "DENY"

    # Extract parameters
    scope = kwargs.get("scope", "ANYONE")
    perms = kwargs. get("perms", {"view"})
    constraints = kwargs.get("constraints", {})

    # Validate Invariant 10: constraints only on ANYONE links
    if constraints and scope != "ANYONE":
        return "DENY"

    # Create link (actual creation happens in test/application code)
    return "GRANT"


def _handle_add_user(user: User, resource: Resource, ctx: Context,
                     state: OneDriveState, kwargs: dict) -> str:
    """
    Handle adding user to SPECIFIC link (Section 9.2).

    Requires kwargs: link, target_user
    """
    link = kwargs.get("link")
    target_user = kwargs.get("target_user")

    if not link or not target_user:
        return "DENY"

    # Check authority
    if not can_manage(user, resource, ctx, state):
        return "DENY"

    # Must be SPECIFIC link
    if link.scope != "SPECIFIC":
        return "DENY"

    # Target must be authenticated user (Invariant 9)
    if target_user. user_type != "authenticated":
        return "DENY"

    return "GRANT"


def _handle_remove_user(user: User, resource: Resource, ctx: Context,
                        state: OneDriveState, kwargs: dict) -> str:
    """
    Handle removing user from SPECIFIC link (Section 9.3).

    Requires kwargs: link, target_user
    """
    link = kwargs.get("link")

    if not link:
        return "DENY"

    # Check authority
    if not can_manage(user, resource, ctx, state):
        return "DENY"

    # Must be SPECIFIC link
    if link.scope != "SPECIFIC":
        return "DENY"

    return "GRANT"


def _handle_delete_link(user: User, resource: Resource, ctx: Context,
                        state: OneDriveState, kwargs: dict) -> str:
    """
    Handle link deletion/revocation (Section 9.4).

    Requires kwargs: link
    """
    link = kwargs. get("link")

    if not link:
        return "DENY"

    # Check authority (CanManage on link's target)
    target = state.resources.get(link.target_rid)
    if not target:
        return "DENY"

    if not can_manage(user, target, ctx, state):
        return "DENY"

    return "GRANT"


def _handle_update_constraints(user: User, resource: Resource, ctx: Context,
                                state: OneDriveState, kwargs: dict) -> str:
    """
    Handle updating link constraints (expiry/password) (Section 9.5).

    Requires kwargs: link, new_constraints
    """
    link = kwargs.get("link")
    new_constraints = kwargs.get("new_constraints")

    if not link or new_constraints is None:
        return "DENY"

    # Check authority
    if not can_manage(user, resource, ctx, state):
        return "DENY"

    # Validate Invariant 10: constraints only on ANYONE links
    if new_constraints and link.scope != "ANYONE":
        return "DENY"

    return "GRANT"


def _handle_change_permissions(user: User, resource: Resource, ctx: Context,
                                state: OneDriveState, kwargs: dict) -> str:
    """
    Handle changing link permissions (Section 9.6).

    Requires kwargs: link, new_perms
    """
    link = kwargs.get("link")
    new_perms = kwargs.get("new_perms")

    if not link or not new_perms:
        return "DENY"

    # Check authority
    if not can_manage(user, resource, ctx, state):
        return "DENY"

    # Validate new_perms is either {view} or {view, edit}
    valid_perms = [{"view"}, {"view", "edit"}]
    if new_perms not in valid_perms:
        return "DENY"

    return "GRANT"


def _handle_copy_resource(user: User, resource: Resource, ctx: Context,
                          state: OneDriveState, kwargs: dict) -> str:
    """
    Handle resource copy operation (Section 9.7).

    Requires kwargs: destination_folder

    Precondition:
        (view âˆˆ TotalPerms(u, source, Î“)) âˆ§
        (edit âˆˆ TotalPerms(u, destination, Î“))
    """
    destination = kwargs.get("destination_folder")

    if not destination:
        return "DENY"

    # Need view on source
    source_perms = total_perms(user, resource, ctx, state)
    if "view" not in source_perms:
        return "DENY"

    # Need edit on destination
    dest_perms = total_perms(user, destination, ctx, state)
    if "edit" not in dest_perms:
        return "DENY"

    return "GRANT"


def _handle_move_resource(user: User, resource: Resource, ctx: Context,
                          state: OneDriveState, kwargs: dict) -> str:
    """
    Handle resource move operation (Section 9. 9).

    Requires kwargs: new_parent

    Precondition:
        CanManage(u, resource, Î“) âˆ§
        (edit âˆˆ TotalPerms(u, new_parent, Î“))
    """
    new_parent = kwargs.get("new_parent")

    if not new_parent:
        return "DENY"

    # Need management authority on source
    if not can_manage(user, resource, ctx, state):
        return "DENY"

    # Need edit on destination
    dest_perms = total_perms(user, new_parent, ctx, state)
    if "edit" not in dest_perms:
        return "DENY"

    return "GRANT"

from datetime import datetime


# ========== Common helpers for tests ==========

def make_base_users():
    """
    Create a standard user set used across tests.

    Returns
    -------
    dict
        Dictionary mapping user_id â†’ User object
    """
    return {
        "owner": User(uid="owner", user_type="owner", name="Owner"),
        "alice": User(uid="alice", user_type="authenticated", name="Alice"),
        "bob":   User(uid="bob", user_type="authenticated", name="Bob"),
        "anon":  User(uid="anon", user_type="anonymous", name="Anonymous"),
    }


# Fixed logical times for tests
NOW = datetime(2025, 1, 1, 12, 0, 0)
ctx_normal = Context(t_now=NOW, auth_level="standard")
ctx_mfa = Context(t_now=NOW, auth_level="mfa")
ctx_future = Context(t_now=datetime(2026, 1, 1, 12, 0, 0))  # for expiry tests


def run_test(name: str, uid: str, rid: str, action: str,
             state: OneDriveState, ctx: Context, expected: str, **kwargs):
    """
    Run a single oracle check and print Expected vs Got.

    Parameters
    ----------
    name : str
        Test case description
    uid : str
        User ID (looked up in state. users)
    rid : str
        Resource ID (looked up in state.resources)
    action : str
        Action to test
    state : OneDriveState
        Current system state
    ctx : Context
        Request context
    expected : str
        Expected result: "GRANT" or "DENY"
    **kwargs : dict
        Additional arguments for administrative actions
    """
    # Lookup user and resource from state
    user = state.users.get(uid)
    resource = state.resources.get(rid)

    if not user or not resource:
        print(f"ERROR    | {name:35} | Missing user/resource in state")
        return

    got = oracle(user, resource, action, ctx, state, **kwargs)
    status = "OK" if got == expected else "MISMATCH"
    print(
        f"{status:9} | {name:35} | "
        f"user={uid:6s} res={rid:5s} action={action:12s} | "
        f"expected={expected:14s} got={got:14s}"
    )

def create_file(rid: str, name: str, parent_id: str = None, is_vault: bool = False):
    """Quick helper to create a file resource."""
    return Resource(
        rid=rid,
        name=name,
        resource_type="file",
        parent_id=parent_id,
        is_vault=is_vault
    )


def create_folder(rid: str, name: str, parent_id: str = None, is_vault: bool = False):
    """Quick helper to create a folder resource."""
    return Resource(
        rid=rid,
        name=name,
        resource_type="folder",
        parent_id=parent_id,
        is_vault=is_vault
    )


def create_link_simple(lid: str, target_rid: str, scope: str, perms: set, constraints: dict = None):
    """Quick helper to create a link."""
    return Link(
        lid=lid,
        target_rid=target_rid,
        scope=scope,
        perms=perms,
        constraints=constraints or {},
        key=f"https://1drv.ms/{lid}"
    )


def make_base_state(owner_id: str = "owner"):
    """Create a minimal OneDrive state with owner and basic structure."""
    users = make_base_users()

    return OneDriveState(
        owner_id=owner_id,
        users=users,
        resources={},
        links={},
        recipients={},
        holding=set()
    )

def all_possible_tests():
    """
    Comprehensive test suite covering ALL scenarios from the formal model.

    Test Coverage:
    - Section 2: System Characteristics (8 tests)
    - Section 6: System Invariants (10 tests)
    - Section 7: Policy Logic (5 predicates)
    - Section 8: Authorization Decision
    - Section 9: All 10 Administrative Operations
    - Edge cases and boundary conditions
    """

    print("\n" + "="*100)
    print("  COMPREHENSIVE TEST SUITE - ALL POSSIBLE SCENARIOS")
    print("="*100)

    # ========== SECTION 1: OWNERSHIP & ROOT ACCESS ==========
    print("\n" + "="*100)
    print("  SECTION 1: OWNERSHIP & ROOT ACCESS (System Characteristic 1)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state. resources["file1"] = create_file("file1", "file1.txt", "root")
    state.resources["folder1"] = create_folder("folder1", "Folder1", "root")
    state.resources["nested"] = create_file("nested", "nested.txt", "folder1")

    print("\n--- Owner has full access to all resources ---")
    run_test("1.1. 1 Owner view file", "owner", "file1", "view", state, ctx_normal, "GRANT")
    run_test("1.1.2 Owner download file", "owner", "file1", "download", state, ctx_normal, "GRANT")
    run_test("1.1. 3 Owner edit file", "owner", "file1", "edit", state, ctx_normal, "GRANT")
    run_test("1.1.4 Owner upload to folder", "owner", "folder1", "upload", state, ctx_normal, "GRANT")
    run_test("1.1. 5 Owner delete file", "owner", "file1", "delete", state, ctx_normal, "GRANT")
    run_test("1.1. 6 Owner delete folder", "owner", "folder1", "delete", state, ctx_normal, "GRANT")
    run_test("1.1.7 Owner share file", "owner", "file1", "share", state, ctx_normal, "GRANT")
    run_test("1.1. 8 Owner share folder", "owner", "folder1", "share", state, ctx_normal, "GRANT")
    run_test("1.1. 9 Owner view nested file", "owner", "nested", "view", state, ctx_normal, "GRANT")
    run_test("1.1.10 Owner edit nested file", "owner", "nested", "edit", state, ctx_normal, "GRANT")

    # ========== SECTION 2: HIERARCHICAL INHERITANCE ==========
    print("\n" + "="*100)
    print("  SECTION 2: HIERARCHICAL INHERITANCE (System Characteristic 2)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state. resources["parent"] = create_folder("parent", "ParentFolder", "root")
    state.resources["child1"] = create_file("child1", "child1.txt", "parent")
    state.resources["child2"] = create_file("child2", "child2.txt", "parent")
    state.resources["grandchild"] = create_folder("grandchild", "GrandchildFolder", "parent")
    state.resources["deepfile"] = create_file("deepfile", "deep.txt", "grandchild")

    # Link on parent folder with view permission
    link_parent_view = create_link_simple("L_parent_view", "parent", "SPECIFIC", {"view"})
    state.links["L_parent_view"] = link_parent_view
    state.recipients["L_parent_view"] = {"alice"}
    state.holding.add(("alice", "L_parent_view"))

    print("\n--- View permission on parent inherits to all descendants ---")
    run_test("2.1. 1 Alice view parent", "alice", "parent", "view", state, ctx_normal, "GRANT")
    run_test("2.1.2 Alice view child1", "alice", "child1", "view", state, ctx_normal, "GRANT")
    run_test("2.1.3 Alice view child2", "alice", "child2", "view", state, ctx_normal, "GRANT")
    run_test("2.1.4 Alice view grandchild", "alice", "grandchild", "view", state, ctx_normal, "GRANT")
    run_test("2.1.5 Alice view deepfile", "alice", "deepfile", "view", state, ctx_normal, "GRANT")
    run_test("2.1.6 Alice cannot edit child1", "alice", "child1", "edit", state, ctx_normal, "DENY")
    run_test("2.1. 7 Alice cannot delete child2", "alice", "child2", "delete", state, ctx_normal, "DENY")

    # Edit permission on parent
    state2 = make_base_state("owner")
    state2.resources["root"] = create_folder("root", "Root")
    state2. resources["parent"] = create_folder("parent", "ParentFolder", "root")
    state2. resources["child1"] = create_file("child1", "child1.txt", "parent")
    state2.resources["child2"] = create_file("child2", "child2.txt", "parent")

    link_parent_edit = create_link_simple("L_parent_edit", "parent", "SPECIFIC", {"view", "edit"})
    state2.links["L_parent_edit"] = link_parent_edit
    state2.recipients["L_parent_edit"] = {"alice"}
    state2.holding. add(("alice", "L_parent_edit"))

    print("\n--- Edit permission on parent inherits to all descendants ---")
    run_test("2.2.1 Alice edit parent", "alice", "parent", "edit", state2, ctx_normal, "GRANT")
    run_test("2.2.2 Alice edit child1", "alice", "child1", "edit", state2, ctx_normal, "GRANT")
    run_test("2.2.3 Alice upload to parent", "alice", "parent", "upload", state2, ctx_normal, "GRANT")
    run_test("2.2.4 Alice delete child1", "alice", "child1", "delete", state2, ctx_normal, "GRANT")
    run_test("2.2.5 Alice cannot delete parent", "alice", "parent", "delete", state2, ctx_normal, "DENY")

    # Multi-level inheritance
    state3 = make_base_state("owner")
    state3.resources["root"] = create_folder("root", "Root")
    state3.resources["level1"] = create_folder("level1", "Level1", "root")
    state3.resources["level2"] = create_folder("level2", "Level2", "level1")
    state3. resources["level3"] = create_folder("level3", "Level3", "level2")
    state3.resources["deepfile"] = create_file("deepfile", "deep.txt", "level3")

    link_level1 = create_link_simple("L_level1", "level1", "ANYONE", {"view", "edit"})
    state3.links["L_level1"] = link_level1
    state3.holding.add(("bob", "L_level1"))

    print("\n--- Deep inheritance across multiple levels ---")
    run_test("2.3.1 Bob view level1", "bob", "level1", "view", state3, ctx_normal, "GRANT")
    run_test("2.3.2 Bob view level2", "bob", "level2", "view", state3, ctx_normal, "GRANT")
    run_test("2.3.3 Bob view level3", "bob", "level3", "view", state3, ctx_normal, "GRANT")
    run_test("2.3.4 Bob edit deepfile", "bob", "deepfile", "edit", state3, ctx_normal, "GRANT")
    run_test("2.3.5 Bob delete deepfile", "bob", "deepfile", "delete", state3, ctx_normal, "GRANT")

    # ========== SECTION 3: PERSONAL VAULT ==========
    print("\n" + "="*100)
    print("  SECTION 3: PERSONAL VAULT (System Characteristic 3)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["vault_folder"] = create_folder("vault_folder", "PersonalVault", "root", is_vault=True)
    state.resources["vault_file1"] = create_file("vault_file1", "secret1.txt", "vault_folder", is_vault=True)
    state.resources["vault_file2"] = create_file("vault_file2", "secret2.txt", "vault_folder", is_vault=True)
    state.resources["normal_file"] = create_file("normal_file", "normal.txt", "root", is_vault=False)

    ctx_no_auth = Context(t_now=NOW, auth_level="none")
    ctx_standard = Context(t_now=NOW, auth_level="standard")
    ctx_mfa = Context(t_now=NOW, auth_level="mfa")

    print("\n--- Owner needs MFA to access Vault ---")
    run_test("3.1.1 Owner vault no auth DENY", "owner", "vault_file1", "view", state, ctx_no_auth, "DENY")
    run_test("3.1.2 Owner vault standard DENY", "owner", "vault_file1", "view", state, ctx_standard, "DENY")
    run_test("3.1.3 Owner vault MFA GRANT", "owner", "vault_file1", "view", state, ctx_mfa, "GRANT")
    run_test("3.1.4 Owner vault edit MFA", "owner", "vault_file1", "edit", state, ctx_mfa, "GRANT")
    run_test("3.1.5 Owner vault delete MFA", "owner", "vault_file1", "delete", state, ctx_mfa, "GRANT")
    run_test("3.1.6 Owner vault folder view MFA", "owner", "vault_folder", "view", state, ctx_mfa, "GRANT")

    print("\n--- Non-owner cannot access Vault even with MFA ---")
    run_test("3.2.1 Alice vault DENY no MFA", "alice", "vault_file1", "view", state, ctx_standard, "DENY")
    run_test("3.2.2 Alice vault DENY with MFA", "alice", "vault_file1", "view", state, ctx_mfa, "DENY")
    run_test("3.2.3 Bob vault DENY", "bob", "vault_file2", "view", state, ctx_mfa, "DENY")
    run_test("3.2.4 Anon vault DENY", "anon", "vault_file1", "view", state, ctx_mfa, "DENY")

    print("\n--- Normal files accessible without MFA ---")
    run_test("3.3.1 Owner normal file no MFA", "owner", "normal_file", "view", state, ctx_standard, "GRANT")
    run_test("3.3.2 Owner normal file edit", "owner", "normal_file", "edit", state, ctx_standard, "GRANT")

    # ========== SECTION 4: LINK-BASED SHARING ==========
    print("\n" + "="*100)
    print("  SECTION 4: LINK-BASED SHARING (System Characteristic 4)")
    print("="*100)

    state = make_base_state("owner")
    state. resources["root"] = create_folder("root", "Root")
    state.resources["file1"] = create_file("file1", "document. txt", "root")

    # Multiple links to same resource
    link1_view = create_link_simple("L1_view", "file1", "ANYONE", {"view"})
    link2_edit = create_link_simple("L2_edit", "file1", "ANYONE", {"view", "edit"})
    link3_specific = create_link_simple("L3_spec", "file1", "SPECIFIC", {"view"})

    state.links["L1_view"] = link1_view
    state.links["L2_edit"] = link2_edit
    state.links["L3_spec"] = link3_specific
    state.recipients["L3_spec"] = {"alice"}

    state.holding.add(("anon", "L1_view"))
    state.holding.add(("bob", "L2_edit"))
    state.holding.add(("alice", "L3_spec"))

    print("\n--- Multiple links with different permissions ---")
    run_test("4.1.1 Anon view via L1", "anon", "file1", "view", state, ctx_normal, "GRANT")
    run_test("4.1.2 Anon cannot edit via L1", "anon", "file1", "edit", state, ctx_normal, "DENY")
    run_test("4.1. 3 Bob view via L2", "bob", "file1", "view", state, ctx_normal, "GRANT")
    run_test("4.1.4 Bob edit via L2", "bob", "file1", "edit", state, ctx_normal, "GRANT")
    run_test("4.1.5 Alice view via L3", "alice", "file1", "view", state, ctx_normal, "GRANT")
    run_test("4. 1.6 Alice cannot edit via L3", "alice", "file1", "edit", state, ctx_normal, "DENY")

    # ANYONE vs SPECIFIC scope
    state2 = make_base_state("owner")
    state2.resources["root"] = create_folder("root", "Root")
    state2.resources["public_file"] = create_file("public_file", "public.txt", "root")
    state2.resources["private_file"] = create_file("private_file", "private.txt", "root")

    link_anyone = create_link_simple("L_anyone", "public_file", "ANYONE", {"view"})
    link_specific = create_link_simple("L_specific", "private_file", "SPECIFIC", {"view"})

    state2.links["L_anyone"] = link_anyone
    state2. links["L_specific"] = link_specific
    state2.recipients["L_specific"] = {"alice"}

    state2. holding.add(("anon", "L_anyone"))
    state2.holding.add(("alice", "L_specific"))
    state2.holding.add(("bob", "L_specific"))  # Bob has URL but not in recipients

    print("\n--- ANYONE scope: possession = access ---")
    run_test("4.2.1 Anon access ANYONE link", "anon", "public_file", "view", state2, ctx_normal, "GRANT")

    print("\n--- SPECIFIC scope: possession + identity required ---")
    run_test("4.2.2 Alice in recipients GRANT", "alice", "private_file", "view", state2, ctx_normal, "GRANT")
    run_test("4.2.3 Bob not in recipients DENY", "bob", "private_file", "view", state2, ctx_normal, "DENY")

    # ========== SECTION 5: PERMISSION GRANULARITY ==========
    print("\n" + "="*100)
    print("  SECTION 5: PERMISSION GRANULARITY (System Characteristic 5)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file_view"] = create_file("file_view", "viewonly.txt", "root")
    state.resources["file_edit"] = create_file("file_edit", "editable.txt", "root")

    link_view = create_link_simple("L_view", "file_view", "SPECIFIC", {"view"})
    link_edit = create_link_simple("L_edit", "file_edit", "SPECIFIC", {"view", "edit"})

    state.links["L_view"] = link_view
    state. links["L_edit"] = link_edit
    state.recipients["L_view"] = {"alice"}
    state.recipients["L_edit"] = {"bob"}
    state.holding.add(("alice", "L_view"))
    state.holding.add(("bob", "L_edit"))

    print("\n--- VIEW permission grants: view + download ---")
    run_test("5.1.1 Alice view", "alice", "file_view", "view", state, ctx_normal, "GRANT")
    run_test("5.1.2 Alice download", "alice", "file_view", "download", state, ctx_normal, "GRANT")
    run_test("5.1.3 Alice cannot edit", "alice", "file_view", "edit", state, ctx_normal, "DENY")
    run_test("5.1. 4 Alice cannot upload", "alice", "file_view", "upload", state, ctx_normal, "DENY")
    run_test("5.1.5 Alice cannot delete", "alice", "file_view", "delete", state, ctx_normal, "DENY")
    run_test("5.1.6 Alice cannot share", "alice", "file_view", "share", state, ctx_normal, "DENY")

    print("\n--- EDIT permission grants: view + download + edit + upload + delete + share ---")
    run_test("5.2.1 Bob view", "bob", "file_edit", "view", state, ctx_normal, "GRANT")
    run_test("5.2. 2 Bob download", "bob", "file_edit", "download", state, ctx_normal, "GRANT")
    run_test("5.2.3 Bob edit", "bob", "file_edit", "edit", state, ctx_normal, "GRANT")
    run_test("5.2. 4 Bob upload", "bob", "file_edit", "upload", state, ctx_normal, "GRANT")
    run_test("5.2.5 Bob delete (child)", "bob", "file_edit", "delete", state, ctx_normal, "GRANT")
    run_test("5.2. 6 Bob share", "bob", "file_edit", "share", state, ctx_normal, "GRANT")

    # ========== SECTION 6: COMBINED PERMISSION EVALUATION ==========
    print("\n" + "="*100)
    print("  SECTION 6: COMBINED PERMISSION EVALUATION (System Characteristic 6)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["folder"] = create_folder("folder", "SharedFolder", "root")
    state.resources["file"] = create_file("file", "document.txt", "folder")

    # Folder has view, file has edit - union should give edit
    link_folder_view = create_link_simple("L_folder_view", "folder", "SPECIFIC", {"view"})
    link_file_edit = create_link_simple("L_file_edit", "file", "SPECIFIC", {"view", "edit"})

    state.links["L_folder_view"] = link_folder_view
    state.links["L_file_edit"] = link_file_edit
    state.recipients["L_folder_view"] = {"alice"}
    state.recipients["L_file_edit"] = {"alice"}
    state.holding.add(("alice", "L_folder_view"))
    state.holding.add(("alice", "L_file_edit"))

    print("\n--- Union: view (inherited) + edit (direct) = edit ---")
    run_test("6.1.1 Alice view file", "alice", "file", "view", state, ctx_normal, "GRANT")
    run_test("6.1.2 Alice edit file", "alice", "file", "edit", state, ctx_normal, "GRANT")

    # Folder has edit, file has view - union should still give edit
    state2 = make_base_state("owner")
    state2. resources["root"] = create_folder("root", "Root")
    state2.resources["folder"] = create_folder("folder", "SharedFolder", "root")
    state2.resources["file"] = create_file("file", "document. txt", "folder")

    link_folder_edit = create_link_simple("L_folder_edit", "folder", "SPECIFIC", {"view", "edit"})
    link_file_view = create_link_simple("L_file_view", "file", "SPECIFIC", {"view"})

    state2.links["L_folder_edit"] = link_folder_edit
    state2.links["L_file_view"] = link_file_view
    state2.recipients["L_folder_edit"] = {"bob"}
    state2.recipients["L_file_view"] = {"bob"}
    state2.holding.add(("bob", "L_folder_edit"))
    state2.holding.add(("bob", "L_file_view"))

    print("\n--- Union: edit (inherited) + view (direct) = edit (no downgrade) ---")
    run_test("6.2.1 Bob view file", "bob", "file", "view", state2, ctx_normal, "GRANT")
    run_test("6.2.2 Bob edit file", "bob", "file", "edit", state2, ctx_normal, "GRANT")
    run_test("6.2.3 Bob cannot downgrade to view-only", "bob", "file", "edit", state2, ctx_normal, "GRANT")

    # Multiple direct links with different permissions
    state3 = make_base_state("owner")
    state3. resources["root"] = create_folder("root", "Root")
    state3.resources["file"] = create_file("file", "shared.txt", "root")

    link1 = create_link_simple("L1", "file", "SPECIFIC", {"view"})
    link2 = create_link_simple("L2", "file", "SPECIFIC", {"view", "edit"})

    state3.links["L1"] = link1
    state3.links["L2"] = link2
    state3.recipients["L1"] = {"alice"}
    state3.recipients["L2"] = {"alice"}
    state3.holding. add(("alice", "L1"))
    state3.holding. add(("alice", "L2"))

    print("\n--- Multiple direct links: view + edit = edit ---")
    run_test("6.3.1 Alice has both links", "alice", "file", "edit", state3, ctx_normal, "GRANT")

    # ========== SECTION 7: STATEFUL CONSTRAINTS ==========
    print("\n" + "="*100)
    print("  SECTION 7: STATEFUL CONSTRAINTS (System Characteristic 7)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state. resources["file1"] = create_file("file1", "file1.txt", "root")
    state.resources["file2"] = create_file("file2", "file2.txt", "root")
    state.resources["file3"] = create_file("file3", "file3.txt", "root")
    state.resources["file4"] = create_file("file4", "file4.txt", "root")

    # Password-protected link
    link_pw = create_link_simple("L_pw", "file1", "ANYONE", {"view"},
                                  constraints={"password": "secret123"})

    # Expired link
    link_expired = create_link_simple("L_expired", "file2", "ANYONE", {"view"},
                                       constraints={"expiry": datetime(2024, 12, 31, 23, 59, 59)})

    # Valid expiry
    link_valid_expiry = create_link_simple("L_valid_exp", "file3", "ANYONE", {"view"},
                                            constraints={"expiry": datetime(2025, 12, 31, 23, 59, 59)})

    # Both password and expiry
    link_both = create_link_simple("L_both", "file4", "ANYONE", {"view"},
                                     constraints={"password": "combo", "expiry": datetime(2025, 12, 31)})

    state.links["L_pw"] = link_pw
    state.links["L_expired"] = link_expired
    state.links["L_valid_exp"] = link_valid_expiry
    state.links["L_both"] = link_both

    state.holding.add(("anon", "L_pw"))
    state.holding.add(("anon", "L_expired"))
    state.holding.add(("anon", "L_valid_exp"))
    state.holding. add(("anon", "L_both"))

    ctx_no_pw = Context(t_now=NOW, auth_level="standard", provided_password=None)
    ctx_wrong_pw = Context(t_now=NOW, auth_level="standard", provided_password="wrong")
    ctx_correct_pw = Context(t_now=NOW, auth_level="standard", provided_password="secret123")
    ctx_combo_pw = Context(t_now=NOW, auth_level="standard", provided_password="combo")
    ctx_future = Context(t_now=datetime(2026, 6, 1), auth_level="standard")

    print("\n--- Password constraints ---")
    run_test("7.1.1 No password DENY", "anon", "file1", "view", state, ctx_no_pw, "DENY")
    run_test("7.1.2 Wrong password DENY", "anon", "file1", "view", state, ctx_wrong_pw, "DENY")
    run_test("7.1.3 Correct password GRANT", "anon", "file1", "view", state, ctx_correct_pw, "GRANT")

    print("\n--- Expiry constraints ---")
    run_test("7.2.1 Expired link DENY", "anon", "file2", "view", state, ctx_normal, "DENY")
    run_test("7.2.2 Valid expiry GRANT", "anon", "file3", "view", state, ctx_normal, "GRANT")
    run_test("7.2. 3 Future time expired DENY", "anon", "file3", "view", state, ctx_future, "DENY")

    print("\n--- Combined constraints ---")
    run_test("7.3.1 Both correct GRANT", "anon", "file4", "view", state, ctx_combo_pw, "GRANT")
    run_test("7.3.2 Wrong password DENY", "anon", "file4", "view", state, ctx_correct_pw, "DENY")
    run_test("7.3.3 No password DENY", "anon", "file4", "view", state, ctx_normal, "DENY")

    # ========== SECTION 8: EXTERNAL INTERACTION ==========
    print("\n" + "="*100)
    print("  SECTION 8: EXTERNAL INTERACTION (System Characteristic 8)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["public"] = create_file("public", "public.txt", "root")
    state.resources["specific"] = create_file("specific", "specific.txt", "root")

    link_public = create_link_simple("L_public", "public", "ANYONE", {"view"})
    link_specific = create_link_simple("L_specific", "specific", "SPECIFIC", {"view"})

    state.links["L_public"] = link_public
    state.links["L_specific"] = link_specific
    state.recipients["L_specific"] = {"alice"}  # alice is authenticated

    state.holding. add(("anon", "L_public"))
    state.holding.add(("alice", "L_specific"))
    state.holding.add(("anon", "L_specific"))  # Anon has URL but not authenticated

    print("\n--- Anonymous users can access ANYONE links ---")
    run_test("8.1.1 Anon access public link", "anon", "public", "view", state, ctx_normal, "GRANT")

    print("\n--- Anonymous users cannot access SPECIFIC links (even with URL) ---")
    run_test("8.1.2 Anon cannot access SPECIFIC", "anon", "specific", "view", state, ctx_normal, "DENY")

    print("\n--- Authenticated users can access SPECIFIC links ---")
    run_test("8. 1.3 Alice access SPECIFIC", "alice", "specific", "view", state, ctx_normal, "GRANT")

    # ========== SECTION 9: INVARIANT TESTS ==========
    print("\n" + "="*100)
    print("  SECTION 9: SYSTEM INVARIANTS")
    print("="*100)

    # Invariant 3: Vault Non-Shareability
    print("\n--- Invariant 3: Vault resources cannot be shared ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["vault"] = create_file("vault", "secret.txt", "root", is_vault=True)

    # Even owner cannot create share links for vault items
    # This would be tested at the operation level, not oracle level
    # Oracle assumes links don't exist for vault items (enforced by invariant)

    # Invariant 6: Vault MFA Requirement
    print("\n--- Invariant 6: Vault requires MFA ---")
    run_test("9.6.1 Vault without MFA DENY", "owner", "vault", "view", state, ctx_normal, "DENY")
    run_test("9.6.2 Vault with MFA GRANT", "owner", "vault", "view", state, ctx_mfa, "GRANT")

    # Invariant 7: Link-State Consistency
    print("\n--- Invariant 7: Links must point to valid resources ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file1"] = create_file("file1", "exists.txt", "root")

    link_valid = create_link_simple("L_valid", "file1", "ANYONE", {"view"})
    state.links["L_valid"] = link_valid
    state.holding.add(("anon", "L_valid"))

    run_test("9.7.1 Valid link target", "anon", "file1", "view", state, ctx_normal, "GRANT")

    # ========== SECTION 10: POSSESSION REQUIREMENT ==========
    print("\n" + "="*100)
    print("  SECTION 10: POSSESSION REQUIREMENT (ValidLink Predicate)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file"] = create_file("file", "document.txt", "root")

    link = create_link_simple("L1", "file", "ANYONE", {"view"})
    state. links["L1"] = link
    state.holding.add(("alice", "L1"))  # Only Alice holds the link

    print("\n--- User must possess (hold) the link ---")
    run_test("10.1.1 Alice holds link GRANT", "alice", "file", "view", state, ctx_normal, "GRANT")
    run_test("10.1.2 Bob doesn't hold link DENY", "bob", "file", "view", state, ctx_normal, "DENY")
    run_test("10.1.3 Anon doesn't hold link DENY", "anon", "file", "view", state, ctx_normal, "DENY")

    # ========== SECTION 11: DELETE SEMANTICS ==========
    print("\n" + "="*100)
    print("  SECTION 11: DELETE SEMANTICS (Section 9. 10)")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["folder"] = create_folder("folder", "SharedFolder", "root")
    state.resources["child"] = create_file("child", "child.txt", "folder")

    link_folder = create_link_simple("L_folder", "folder", "SPECIFIC", {"view", "edit"})
    state. links["L_folder"] = link_folder
    state.recipients["L_folder"] = {"alice"}
    state.holding.add(("alice", "L_folder"))

    print("\n--- Delete requires edit on PARENT, not resource itself ---")
    run_test("11.1.1 Alice can delete child (has edit on parent)", "alice", "child", "delete", state, ctx_normal, "GRANT")
    run_test("11.1.2 Alice cannot delete folder (no edit on root)", "alice", "folder", "delete", state, ctx_normal, "DENY")
    run_test("11.1.3 Owner can delete anything", "owner", "folder", "delete", state, ctx_normal, "GRANT")

    # User with direct edit on file but not parent
    state2 = make_base_state("owner")
    state2.resources["root"] = create_folder("root", "Root")
    state2.resources["folder"] = create_folder("folder", "Folder", "root")
    state2.resources["file"] = create_file("file", "file. txt", "folder")

    link_file_only = create_link_simple("L_file", "file", "SPECIFIC", {"view", "edit"})
    state2.links["L_file"] = link_file_only
    state2.recipients["L_file"] = {"bob"}
    state2.holding. add(("bob", "L_file"))

    print("\n--- Direct edit on file doesn't allow deletion ---")
    run_test("11.2.1 Bob edit file OK", "bob", "file", "edit", state2, ctx_normal, "GRANT")
    run_test("11.2.2 Bob delete file DENY (no parent access)", "bob", "file", "delete", state2, ctx_normal, "DENY")

    # ========== SECTION 12: RE-SHARING (SHARE ACTION) ==========
    print("\n" + "="*100)
    print("  SECTION 12: RE-SHARING CAPABILITY")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file_view"] = create_file("file_view", "viewonly.txt", "root")
    state.resources["file_edit"] = create_file("file_edit", "editable.txt", "root")

    link_view = create_link_simple("L_view", "file_view", "SPECIFIC", {"view"})
    link_edit = create_link_simple("L_edit", "file_edit", "SPECIFIC", {"view", "edit"})

    state.links["L_view"] = link_view
    state.links["L_edit"] = link_edit
    state.recipients["L_view"] = {"alice"}
    state.recipients["L_edit"] = {"bob"}
    state.holding.add(("alice", "L_view"))
    state.holding.add(("bob", "L_edit"))

    print("\n--- Only EDIT permission allows re-sharing ---")
    run_test("12.1. 1 Alice view-only cannot share", "alice", "file_view", "share", state, ctx_normal, "DENY")
    run_test("12.1.2 Bob edit can share", "bob", "file_edit", "share", state, ctx_normal, "GRANT")
    run_test("12.1.3 Owner can always share", "owner", "file_view", "share", state, ctx_normal, "GRANT")

    # ========== SECTION 13: EDGE CASES ==========
    print("\n" + "="*100)
    print("  SECTION 13: EDGE CASES & BOUNDARY CONDITIONS")
    print("="*100)

    # Empty state
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["orphan"] = create_file("orphan", "orphan.txt", "root")

    print("\n--- User without any links cannot access ---")
    run_test("13.1.1 Alice no links DENY", "alice", "orphan", "view", state, ctx_normal, "DENY")
    run_test("13.1.2 Bob no links DENY", "bob", "orphan", "view", state, ctx_normal, "DENY")
    run_test("13.1.3 Anon no links DENY", "anon", "orphan", "view", state, ctx_normal, "DENY")

    # Root folder access
    state2 = make_base_state("owner")
    state2.resources["root"] = create_folder("root", "Root")

    print("\n--- Root folder access ---")
    run_test("13.2.1 Owner can access root", "owner", "root", "view", state2, ctx_normal, "GRANT")
    run_test("13. 2.2 Non-owner cannot access root", "alice", "root", "view", state2, ctx_normal, "DENY")

    # Deeply nested structure (10 levels)
    state3 = make_base_state("owner")
    state3.resources["root"] = create_folder("root", "Root")
    parent = "root"
    for i in range(10):
        folder_id = f"level{i}"
        state3.resources[folder_id] = create_folder(folder_id, f"Level{i}", parent)
        parent = folder_id
    state3.resources["deepfile"] = create_file("deepfile", "deep.txt", parent)

    link_root = create_link_simple("L_root", "root", "ANYONE", {"view", "edit"})
    state3.links["L_root"] = link_root
    state3. holding.add(("anon", "L_root"))

    print("\n--- Deep inheritance (10 levels) ---")
    run_test("13.3. 1 Deep file inherits from root", "anon", "deepfile", "edit", state3, ctx_normal, "GRANT")

    # Multiple users same link
    state4 = make_base_state("owner")
    state4.resources["root"] = create_folder("root", "Root")
    state4.resources["shared"] = create_file("shared", "shared.txt", "root")

    link_multi = create_link_simple("L_multi", "shared", "SPECIFIC", {"view"})
    state4.links["L_multi"] = link_multi
    state4.recipients["L_multi"] = {"alice", "bob"}
    state4. holding.add(("alice", "L_multi"))
    state4.holding.add(("bob", "L_multi"))

    print("\n--- Multiple users with same link ---")
    run_test("13.4.1 Alice via shared link", "alice", "shared", "view", state4, ctx_normal, "GRANT")
    run_test("13.4. 2 Bob via shared link", "bob", "shared", "view", state4, ctx_normal, "GRANT")

    # Permission effective expansion
    state5 = make_base_state("owner")
    state5.resources["root"] = create_folder("root", "Root")
    state5.resources["file"] = create_file("file", "test.txt", "root")

    link_edit = create_link_simple("L_edit", "file", "ANYONE", {"view", "edit"})
    state5.links["L_edit"] = link_edit
    state5.holding.add(("anon", "L_edit"))

    print("\n--- Edit permission includes view (permission expansion) ---")
    run_test("13.5.1 Edit includes view", "anon", "file", "view", state5, ctx_normal, "GRANT")
    run_test("13.5.2 Edit includes download", "anon", "file", "download", state5, ctx_normal, "GRANT")
    run_test("13.5.3 Edit allows edit", "anon", "file", "edit", state5, ctx_normal, "GRANT")

    # No holding but in recipients (shouldn't grant access)
    state6 = make_base_state("owner")
    state6.resources["root"] = create_folder("root", "Root")
    state6.resources["file"] = create_file("file", "test.txt", "root")

    link_spec = create_link_simple("L_spec", "file", "SPECIFIC", {"view"})
    state6.links["L_spec"] = link_spec
    state6.recipients["L_spec"] = {"alice"}
    # Note: alice NOT in holding

    print("\n--- Being in recipients without holding link = DENY ---")
    run_test("13.6.1 Recipient without possession DENY", "alice", "file", "view", state6, ctx_normal, "DENY")

    # ========== SECTION 14: ADMINISTRATIVE ACTIONS ==========
    print("\n" + "="*100)
    print("  SECTION 14: ADMINISTRATIVE ACTIONS (Section 9)")
    print("="*100)

    # Create Link
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file"] = create_file("file", "doc.txt", "root")
    state.resources["vault_file"] = create_file("vault_file", "secret.txt", "root", is_vault=True)

    print("\n--- Create Link (Section 9.1) ---")
    run_test("14.1.1 Owner can create link", "owner", "file", "create_link", state, ctx_normal, "GRANT",
             scope="ANYONE", perms={"view"}, constraints={})
    run_test("14.1.2 Cannot create link for Vault", "owner", "vault_file", "create_link", state, ctx_mfa, "DENY",
             scope="ANYONE", perms={"view"}, constraints={})

    # User with edit can create link
    link_edit = create_link_simple("L_edit", "file", "SPECIFIC", {"view", "edit"})
    state.links["L_edit"] = link_edit
    state.recipients["L_edit"] = {"alice"}
    state. holding.add(("alice", "L_edit"))

    run_test("14.1.3 Alice with edit can create link", "alice", "file", "create_link", state, ctx_normal, "GRANT",
             scope="SPECIFIC", perms={"view"}, constraints={})

    # User with view cannot create link
    state2 = make_base_state("owner")
    state2. resources["root"] = create_folder("root", "Root")
    state2.resources["file"] = create_file("file", "doc.txt", "root")

    link_view = create_link_simple("L_view", "file", "SPECIFIC", {"view"})
    state2.links["L_view"] = link_view
    state2.recipients["L_view"] = {"bob"}
    state2.holding. add(("bob", "L_view"))

    run_test("14.1.4 Bob with view cannot create link", "bob", "file", "create_link", state2, ctx_normal, "DENY",
             scope="ANYONE", perms={"view"}, constraints={})

    # Invariant 10: Constraints only on ANYONE links
    run_test("14.1.5 Constraints on SPECIFIC link DENY", "owner", "file", "create_link", state, ctx_normal, "DENY",
             scope="SPECIFIC", perms={"view"}, constraints={"password": "test"})
    run_test("14.1.6 Constraints on ANYONE link OK", "owner", "file", "create_link", state, ctx_normal, "GRANT",
             scope="ANYONE", perms={"view"}, constraints={"password": "test"})

    # Add User
    print("\n--- Add User (Section 9.2) ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file"] = create_file("file", "doc.txt", "root")

    link_spec = create_link_simple("L_spec", "file", "SPECIFIC", {"view"})
    state.links["L_spec"] = link_spec
    state. recipients["L_spec"] = {"alice"}
    state.holding. add(("alice", "L_spec"))

    bob_user = state.users["bob"]
    anon_user = state.users["anon"]

    run_test("14.2.1 Owner can add user to SPECIFIC", "owner", "file", "add_user", state, ctx_normal, "GRANT",
             link=link_spec, target_user=bob_user)
    run_test("14. 2.2 Cannot add anon to SPECIFIC (Invariant 9)", "owner", "file", "add_user", state, ctx_normal, "DENY",
             link=link_spec, target_user=anon_user)

    # Cannot add user to ANYONE link
    link_anyone = create_link_simple("L_anyone", "file", "ANYONE", {"view"})
    state.links["L_anyone"] = link_anyone

    run_test("14.2.3 Cannot add user to ANYONE link", "owner", "file", "add_user", state, ctx_normal, "DENY",
             link=link_anyone, target_user=bob_user)

    # Remove User
    print("\n--- Remove User (Section 9.3) ---")
    run_test("14.3.1 Owner can remove user from SPECIFIC", "owner", "file", "remove_user", state, ctx_normal, "GRANT",
             link=link_spec, target_user=state.users["alice"])
    run_test("14.3.2 Cannot remove from ANYONE link", "owner", "file", "remove_user", state, ctx_normal, "DENY",
             link=link_anyone, target_user=anon_user)

    # Delete Link
    print("\n--- Delete Link (Section 9.4) ---")
    run_test("14.4.1 Owner can delete link", "owner", "file", "delete_link", state, ctx_normal, "GRANT",
             link=link_spec)

    # User with edit can delete link
    state2 = make_base_state("owner")
    state2. resources["root"] = create_folder("root", "Root")
    state2.resources["file"] = create_file("file", "doc.txt", "root")

    link1 = create_link_simple("L1", "file", "SPECIFIC", {"view", "edit"})
    link2 = create_link_simple("L2", "file", "SPECIFIC", {"view"})
    state2.links["L1"] = link1
    state2.links["L2"] = link2
    state2.recipients["L1"] = {"alice"}
    state2.recipients["L2"] = {"alice"}
    state2.holding. add(("alice", "L1"))
    state2.holding. add(("alice", "L2"))

    run_test("14.4.2 Alice with edit can delete link", "alice", "file", "delete_link", state2, ctx_normal, "GRANT",
             link=link2)

    # User with view cannot delete link
    state3 = make_base_state("owner")
    state3.resources["root"] = create_folder("root", "Root")
    state3.resources["file"] = create_file("file", "doc.txt", "root")

    link_v = create_link_simple("L_v", "file", "SPECIFIC", {"view"})
    link_target = create_link_simple("L_target", "file", "ANYONE", {"view"})
    state3.links["L_v"] = link_v
    state3.links["L_target"] = link_target
    state3. recipients["L_v"] = {"bob"}
    state3.holding.add(("bob", "L_v"))

    run_test("14.4.3 Bob with view cannot delete link", "bob", "file", "delete_link", state3, ctx_normal, "DENY",
             link=link_target)

    # Update Constraints
    print("\n--- Update Constraints (Section 9.5) ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file"] = create_file("file", "doc.txt", "root")

    link_any = create_link_simple("L_any", "file", "ANYONE", {"view"})
    link_spec2 = create_link_simple("L_spec", "file", "SPECIFIC", {"view"})
    state.links["L_any"] = link_any
    state.links["L_spec"] = link_spec2
    state.recipients["L_spec"] = {"alice"}

    new_constraints = {"password": "newpass"}

    run_test("14.5.1 Update constraints on ANYONE OK", "owner", "file", "update_constraints", state, ctx_normal, "GRANT",
             link=link_any, new_constraints=new_constraints)
    run_test("14.5.2 Update constraints on SPECIFIC DENY (Invariant 10)", "owner", "file", "update_constraints", state, ctx_normal, "DENY",
             link=link_spec2, new_constraints=new_constraints)

    # Change Permissions
    print("\n--- Change Permissions (Section 9.6) ---")
    run_test("14.6.1 Owner can change to view", "owner", "file", "change_permissions", state, ctx_normal, "GRANT",
             link=link_any, new_perms={"view"})
    run_test("14. 6.2 Owner can change to edit", "owner", "file", "change_permissions", state, ctx_normal, "GRANT",
             link=link_any, new_perms={"view", "edit"})

    # Invalid permission set
    run_test("14.6.3 Invalid perms DENY", "owner", "file", "change_permissions", state, ctx_normal, "DENY",
             link=link_any, new_perms={"edit"})  # Missing view

    # Copy Resource
    print("\n--- Copy Resource (Section 9.7) ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["source"] = create_file("source", "original.txt", "root")
    state.resources["dest_folder"] = create_folder("dest_folder", "Destination", "root")

    link_src_view = create_link_simple("L_src", "source", "SPECIFIC", {"view"})
    link_dest_edit = create_link_simple("L_dest", "dest_folder", "SPECIFIC", {"view", "edit"})

    state.links["L_src"] = link_src_view
    state.links["L_dest"] = link_dest_edit
    state.recipients["L_src"] = {"alice"}
    state.recipients["L_dest"] = {"alice"}
    state.holding.add(("alice", "L_src"))
    state.holding.add(("alice", "L_dest"))

    dest_obj = state.resources["dest_folder"]

    run_test("14.7.1 Alice can copy (view source + edit dest)", "alice", "source", "copy", state, ctx_normal, "GRANT",
             destination_folder=dest_obj)

    # Cannot copy without view on source
    state2 = make_base_state("owner")
    state2. resources["root"] = create_folder("root", "Root")
    state2.resources["source"] = create_file("source", "original.txt", "root")
    state2.resources["dest_folder"] = create_folder("dest_folder", "Destination", "root")

    link_dest2 = create_link_simple("L_dest", "dest_folder", "SPECIFIC", {"view", "edit"})
    state2.links["L_dest"] = link_dest2
    state2.recipients["L_dest"] = {"bob"}
    state2. holding.add(("bob", "L_dest"))

    dest_obj2 = state2. resources["dest_folder"]

    run_test("14. 7.2 Bob cannot copy (no view on source)", "bob", "source", "copy", state2, ctx_normal, "DENY",
             destination_folder=dest_obj2)

    # Move Resource
    print("\n--- Move Resource (Section 9.9) ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["file"] = create_file("file", "moveme.txt", "root")
    state.resources["new_parent"] = create_folder("new_parent", "NewParent", "root")

    link_file = create_link_simple("L_file", "file", "SPECIFIC", {"view", "edit"})
    link_parent = create_link_simple("L_parent", "new_parent", "SPECIFIC", {"view", "edit"})

    state.links["L_file"] = link_file
    state. links["L_parent"] = link_parent
    state.recipients["L_file"] = {"alice"}
    state.recipients["L_parent"] = {"alice"}
    state.holding.add(("alice", "L_file"))
    state.holding.add(("alice", "L_parent"))

    new_parent_obj = state.resources["new_parent"]

    run_test("14.8.1 Alice can move (edit on both)", "alice", "file", "move", state, ctx_normal, "GRANT",
             new_parent=new_parent_obj)

    # Cannot move without edit on destination
    state2 = make_base_state("owner")
    state2.resources["root"] = create_folder("root", "Root")
    state2.resources["file"] = create_file("file", "moveme.txt", "root")
    state2.resources["new_parent"] = create_folder("new_parent", "NewParent", "root")

    link_f = create_link_simple("L_f", "file", "SPECIFIC", {"view", "edit"})
    state2.links["L_f"] = link_f
    state2.recipients["L_f"] = {"bob"}
    state2.holding.add(("bob", "L_f"))

    np_obj = state2.resources["new_parent"]

    run_test("14.8.2 Bob cannot move (no edit on dest)", "bob", "file", "move", state2, ctx_normal, "DENY",
             new_parent=np_obj)

    # ========== SECTION 15: COMPLEX SCENARIOS ==========
    print("\n" + "="*100)
    print("  SECTION 15: COMPLEX REAL-WORLD SCENARIOS")
    print("="*100)



    # Folder shared with edit for team members
    link_team = create_link_simple("L_team", "team_folder", "SPECIFIC", {"view", "edit"})
    state.links["L_team"] = link_team
    state.recipients["L_team"] = {"alice", "bob"}
    state.holding.add(("alice", "L_team"))
    state.holding.add(("bob", "L_team"))

    run_test("15.1.1 Alice edit doc1", "alice", "doc1", "edit", state, ctx_normal, "GRANT")
    run_test("15.1.2 Alice edit doc2", "alice", "doc2", "edit", state, ctx_normal, "GRANT")
    run_test("15. 1.3 Bob edit nested image", "bob", "image", "edit", state, ctx_normal, "GRANT")
    run_test("15.1.4 Alice upload to team folder", "alice", "team_folder", "upload", state, ctx_normal, "GRANT")
    run_test("15.1. 5 Bob delete doc1", "bob", "doc1", "delete", state, ctx_normal, "GRANT")
    run_test("15.1. 6 Alice cannot delete team_folder", "alice", "team_folder", "delete", state, ctx_normal, "DENY")
    run_test("15.1.7 Alice can re-share doc1", "alice", "doc1", "share", state, ctx_normal, "GRANT")

    # Scenario 2: Public sharing with restrictions
    print("\n--- Scenario 2: Public Link with Password & Expiry ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["report"] = create_file("report", "Q4_Report.pdf", "root")

    expiry_time = datetime(2025, 2, 1, 0, 0, 0)
    link_public = create_link_simple("L_public", "report", "ANYONE", {"view"},
                                      constraints={"password": "Q4pass", "expiry": expiry_time})
    state.links["L_public"] = link_public
    state.holding.add(("anon", "L_public"))

    ctx_correct = Context(t_now=NOW, auth_level="standard", provided_password="Q4pass")
    ctx_wrong = Context(t_now=NOW, auth_level="standard", provided_password="wrong")
    ctx_expired = Context(t_now=datetime(2025, 3, 1), auth_level="standard", provided_password="Q4pass")

    run_test("15.2.1 Correct password & valid time", "anon", "report", "view", state, ctx_correct, "GRANT")
    run_test("15. 2.2 Wrong password", "anon", "report", "view", state, ctx_wrong, "DENY")
    run_test("15.2.3 Expired link", "anon", "report", "view", state, ctx_expired, "DENY")

    # Scenario 3: Read-only external reviewer
    print("\n--- Scenario 3: External Reviewer (View-Only) ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["draft"] = create_file("draft", "manuscript. docx", "root")

    link_reviewer = create_link_simple("L_reviewer", "draft", "SPECIFIC", {"view"})
    state.links["L_reviewer"] = link_reviewer
    state.recipients["L_reviewer"] = {"alice"}
    state.holding.add(("alice", "L_reviewer"))

    run_test("15.3.1 Reviewer can view", "alice", "draft", "view", state, ctx_normal, "GRANT")
    run_test("15.3.2 Reviewer can download", "alice", "draft", "download", state, ctx_normal, "GRANT")
    run_test("15.3.3 Reviewer cannot edit", "alice", "draft", "edit", state, ctx_normal, "DENY")
    run_test("15.3.4 Reviewer cannot share", "alice", "draft", "share", state, ctx_normal, "DENY")

    # Scenario 4: Escalated permissions (view folder + edit file)
    print("\n--- Scenario 4: Permission Escalation via Multiple Links ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["folder"] = create_folder("folder", "Project", "root")
    state. resources["file"] = create_file("file", "important.txt", "folder")

    link_folder_view = create_link_simple("L_folder", "folder", "SPECIFIC", {"view"})
    link_file_edit = create_link_simple("L_file", "file", "SPECIFIC", {"view", "edit"})

    state.links["L_folder"] = link_folder_view
    state.links["L_file"] = link_file_edit
    state.recipients["L_folder"] = {"bob"}
    state.recipients["L_file"] = {"bob"}
    state.holding.add(("bob", "L_folder"))
    state.holding.add(("bob", "L_file"))

    run_test("15.4. 1 Bob view via folder link", "bob", "file", "view", state, ctx_normal, "GRANT")
    run_test("15.4. 2 Bob edit via file link", "bob", "file", "edit", state, ctx_normal, "GRANT")
    run_test("15.4. 3 Union gives edit permission", "bob", "file", "edit", state, ctx_normal, "GRANT")

    # Scenario 5: Nested folders with different permissions
    print("\n--- Scenario 5: Nested Folders with Mixed Permissions ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["parent"] = create_folder("parent", "Parent", "root")
    state.resources["child"] = create_folder("child", "Child", "parent")
    state.resources["file"] = create_file("file", "nested.txt", "child")

    # Parent: view-only, Child: edit
    link_parent = create_link_simple("L_parent", "parent", "SPECIFIC", {"view"})
    link_child = create_link_simple("L_child", "child", "SPECIFIC", {"view", "edit"})

    state.links["L_parent"] = link_parent
    state.links["L_child"] = link_child
    state.recipients["L_parent"] = {"alice"}
    state.recipients["L_child"] = {"alice"}
    state.holding.add(("alice", "L_parent"))
    state.holding.add(("alice", "L_child"))

    run_test("15.5.1 Alice view parent", "alice", "parent", "view", state, ctx_normal, "GRANT")
    run_test("15.5.2 Alice cannot edit parent", "alice", "parent", "edit", state, ctx_normal, "DENY")
    run_test("15.5.3 Alice view child", "alice", "child", "view", state, ctx_normal, "GRANT")
    run_test("15.5.4 Alice edit child", "alice", "child", "edit", state, ctx_normal, "GRANT")
    run_test("15.5.5 Alice edit nested file", "alice", "file", "edit", state, ctx_normal, "GRANT")
    run_test("15.5.6 Alice delete nested file", "alice", "file", "delete", state, ctx_normal, "GRANT")

    # Scenario 6: Vault with sensitive data
    print("\n--- Scenario 6: Vault Protection for Sensitive Data ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["vault"] = create_folder("vault", "PersonalVault", "root", is_vault=True)
    state.resources["tax_doc"] = create_file("tax_doc", "taxes_2024.pdf", "vault", is_vault=True)
    state.resources["passwords"] = create_file("passwords", "passwords.txt", "vault", is_vault=True)
    state.resources["normal"] = create_file("normal", "shopping_list.txt", "root")

    run_test("15.6.1 Owner vault file needs MFA", "owner", "tax_doc", "view", state, ctx_normal, "DENY")
    run_test("15.6.2 Owner vault with MFA", "owner", "tax_doc", "view", state, ctx_mfa, "GRANT")
    run_test("15.6. 3 Owner vault edit MFA", "owner", "passwords", "edit", state, ctx_mfa, "GRANT")
    run_test("15.6.4 Owner normal file no MFA", "owner", "normal", "view", state, ctx_normal, "GRANT")
    run_test("15.6. 5 Non-owner vault denied", "alice", "tax_doc", "view", state, ctx_mfa, "DENY")

    # Scenario 7: Link revocation simulation
    print("\n--- Scenario 7: Access Before and After Link Removal ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["shared"] = create_file("shared", "shared.txt", "root")

    link = create_link_simple("L_temp", "shared", "SPECIFIC", {"view"})
    state. links["L_temp"] = link
    state.recipients["L_temp"] = {"alice"}
    state.holding.add(("alice", "L_temp"))

    run_test("15.7.1 Alice can access with link", "alice", "shared", "view", state, ctx_normal, "GRANT")

    # Simulate link deletion
    del state.links["L_temp"]
    del state.recipients["L_temp"]
    state.holding.remove(("alice", "L_temp"))

    run_test("15.7.2 Alice cannot access after revocation", "alice", "shared", "view", state, ctx_normal, "DENY")

    # Scenario 8: Multiple recipients on SPECIFIC link
    print("\n--- Scenario 8: Collaboration via SPECIFIC Link ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["collab"] = create_file("collab", "collaboration.txt", "root")

    link_collab = create_link_simple("L_collab", "collab", "SPECIFIC", {"view", "edit"})
    state. links["L_collab"] = link_collab
    state. recipients["L_collab"] = {"alice", "bob"}
    state. holding.add(("alice", "L_collab"))
    state.holding.add(("bob", "L_collab"))

    run_test("15. 8.1 Alice can edit", "alice", "collab", "edit", state, ctx_normal, "GRANT")
    run_test("15.8.2 Bob can edit", "bob", "collab", "edit", state, ctx_normal, "GRANT")
    run_test("15.8.3 Both can share", "alice", "collab", "share", state, ctx_normal, "GRANT")
    run_test("15.8.4 Both can share", "bob", "collab", "share", state, ctx_normal, "GRANT")

    # Remove one recipient
    state.recipients["L_collab"]. remove("bob")

    run_test("15.8.5 Alice still has access", "alice", "collab", "edit", state, ctx_normal, "GRANT")
    run_test("15.8.6 Bob loses access", "bob", "collab", "view", state, ctx_normal, "DENY")

    # Scenario 9: Folder hierarchy with partial access
    print("\n--- Scenario 9: Partial Folder Hierarchy Access ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["public"] = create_folder("public", "Public", "root")
    state.resources["private"] = create_folder("private", "Private", "root")
    state.resources["public_file"] = create_file("public_file", "public.txt", "public")
    state. resources["private_file"] = create_file("private_file", "private.txt", "private")

    # Only share public folder
    link_public = create_link_simple("L_public", "public", "ANYONE", {"view"})
    state.links["L_public"] = link_public
    state.holding.add(("anon", "L_public"))

    run_test("15.9.1 Anon can access public folder", "anon", "public", "view", state, ctx_normal, "GRANT")
    run_test("15.9.2 Anon can access public file", "anon", "public_file", "view", state, ctx_normal, "GRANT")
    run_test("15.9.3 Anon cannot access private folder", "anon", "private", "view", state, ctx_normal, "DENY")
    run_test("15.9.4 Anon cannot access private file", "anon", "private_file", "view", state, ctx_normal, "DENY")

    # Scenario 10: Time-limited sharing
    print("\n--- Scenario 10: Time-Limited Public Sharing ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["event"] = create_file("event", "event_details.pdf", "root")

    future_expiry = datetime(2025, 6, 1, 0, 0, 0)
    link_event = create_link_simple("L_event", "event", "ANYONE", {"view"},
                                     constraints={"expiry": future_expiry})
    state.links["L_event"] = link_event
    state.holding.add(("anon", "L_event"))

    ctx_jan = Context(t_now=datetime(2025, 1, 15), auth_level="standard")
    ctx_may = Context(t_now=datetime(2025, 5, 15), auth_level="standard")
    ctx_july = Context(t_now=datetime(2025, 7, 15), auth_level="standard")

    run_test("15.10.1 Access in January (valid)", "anon", "event", "view", state, ctx_jan, "GRANT")
    run_test("15.10.2 Access in May (valid)", "anon", "event", "view", state, ctx_may, "GRANT")
    run_test("15.10.3 Access in July (expired)", "anon", "event", "view", state, ctx_july, "DENY")

    # ========== SECTION 16: PERMISSION INHERITANCE EDGE CASES ==========
    print("\n" + "="*100)
    print("  SECTION 16: PERMISSION INHERITANCE EDGE CASES")
    print("="*100)

    # No direct link but has inherited permission
    print("\n--- Direct vs Inherited Permissions ---")
    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state. resources["parent"] = create_folder("parent", "Parent", "root")
    state.resources["child"] = create_file("child", "child.txt", "parent")

    link_parent = create_link_simple("L_parent", "parent", "SPECIFIC", {"view", "edit"})
    state. links["L_parent"] = link_parent
    state.recipients["L_parent"] = {"alice"}
    state.holding.add(("alice", "L_parent"))

    run_test("16.1.1 Alice has no direct link to child", "alice", "child", "view", state, ctx_normal, "GRANT")
    run_test("16.1.2 Child inherits edit from parent", "alice", "child", "edit", state, ctx_normal, "GRANT")
    run_test("16.1.3 Alice cannot access parent's parent", "alice", "root", "view", state, ctx_normal, "DENY")

    # Link to file doesn't give permission to parent
    print("\n--- File Link Doesn't Grant Parent Access ---")
    state2 = make_base_state("owner")
    state2.resources["root"] = create_folder("root", "Root")
    state2.resources["folder"] = create_folder("folder", "Folder", "root")
    state2.resources["file"] = create_file("file", "isolated.txt", "folder")

    link_file = create_link_simple("L_file", "file", "SPECIFIC", {"view", "edit"})
    state2.links["L_file"] = link_file
    state2.recipients["L_file"] = {"bob"}
    state2.holding. add(("bob", "L_file"))

    run_test("16.2.1 Bob can access file", "bob", "file", "view", state2, ctx_normal, "GRANT")
    run_test("16.2.2 Bob cannot access folder", "bob", "folder", "view", state2, ctx_normal, "DENY")
    run_test("16.2.3 Bob cannot access root", "bob", "root", "view", state2, ctx_normal, "DENY")

    # ========== SECTION 17: CONSTRAINT COMBINATIONS ==========
    print("\n" + "="*100)
    print("  SECTION 17: CONSTRAINT COMBINATIONS")
    print("="*100)

    state = make_base_state("owner")
    state.resources["root"] = create_folder("root", "Root")
    state.resources["f1"] = create_file("f1", "no_constraints.txt", "root")
    state.resources["f2"] = create_file("f2", "pw_only.txt", "root")
    state.resources["f3"] = create_file("f3", "expiry_only.txt", "root")
    state.resources["f4"] = create_file("f4", "both.txt", "root")

    link_none = create_link_simple("L_none", "f1", "ANYONE", {"view"}, constraints={})
    link_pw = create_link_simple("L_pw", "f2", "ANYONE", {"view"},
                                  constraints={"password": "test123"})
    link_exp = create_link_simple("L_exp", "f3", "ANYONE", {"view"},
                                   constraints={"expiry": datetime(2025, 6, 1)})
    link_both = create_link_simple("L_both", "f4", "ANYONE", {"view"},
                                    constraints={"password": "combo", "expiry": datetime(2025, 6, 1)})

    state.links["L_none"] = link_none
    state.links["L_pw"] = link_pw
    state.links["L_exp"] = link_exp
    state. links["L_both"] = link_both

    state.holding.add(("anon", "L_none"))
    state. holding.add(("anon", "L_pw"))
    state.holding.add(("anon", "L_exp"))
    state.holding.add(("anon", "L_both"))

    ctx_no_cred = Context(t_now=NOW, auth_level="standard")
    ctx_pw_ok = Context(t_now=NOW, auth_level="standard", provided_password="test123")
    ctx_combo_ok = Context(t_now=NOW, auth_level="standard", provided_password="combo")
    ctx_future_combo = Context(t_now=datetime(2025, 7, 1), auth_level="standard", provided_password="combo")

    print("\n--- No Constraints ---")
    run_test("17.1.1 No constraints always works", "anon", "f1", "view", state, ctx_no_cred, "GRANT")

    print("\n--- Password Only ---")
    run_test("17.2.1 Password required", "anon", "f2", "view", state, ctx_no_cred, "DENY")
    run_test("17.2.2 Password provided", "anon", "f2", "view", state, ctx_pw_ok, "GRANT")

    print("\n--- Expiry Only ---")
    run_test("17.3.1 Before expiry", "anon", "f3", "view", state, ctx_no_cred, "GRANT")
    run_test("17.3.2 After expiry", "anon", "f3", "view", state, ctx_future_combo, "DENY")

    print("\n--- Both Password and Expiry ---")
    run_test("17.4.1 Both satisfied", "anon", "f4", "view", state, ctx_combo_ok, "GRANT")
    run_test("17. 4.2 Password but expired", "anon", "f4", "view", state, ctx_future_combo, "DENY")
    run_test("17.4.3 No password before expiry", "anon", "f4", "view", state, ctx_no_cred, "DENY")

    # ========== FINAL SUMMARY ==========
    print("\n" + "="*100)
    print("  TEST SUITE COMPLETE")
    print("="*100)
    print("\nâœ“ All possible test scenarios executed")
    print("âœ“ Coverage includes:")
    print("  - All 8 System Characteristics")
    print("  - All 10 System Invariants")
    print("  - All 5 Policy Predicates")
    print("  - Authorization Decision Function")
    print("  - All 10 Administrative Operations")
    print("  - Edge cases and boundary conditions")
    print("  - Real-world collaboration scenarios")
    print("  - Constraint combinations")
    print("  - Permission inheritance patterns")
    print("\n" + "="*100 + "\n")

all_possible_tests()